# -线程与进程基本知识
（整理自CSDN博主luoweifu的博客）

1.任务调度采用的是时间片轮转的抢占式调度方式
2.早期操作系统中没有线程的概念，只有进程的概念，后来随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，于是发明线程
3.线程（Lightweight Process,LWP轻量级进程）是程序执行中一个单一的顺序控制流程，是程序执行流的最小单位，是处理器调度和分配的基本单位，是一个进程中代码的不同执行路线
4.进程是操作系统分配资源的最小单位，进程之间相互独立，是一个具有一定独立功能的程序在数据集上的一次动态执行的过程，是应用程序运行的载体
5.线程上下文切换要比进程上下文切换快得多
6.线程有线程ID，当前指令指针（PC），寄存器和堆栈组成
7.进程由内存空间（代码，数据，进程空间，打开的文件）和一个或多个线程组成
8.进程的特征：
a.动态性：进程是程序的一次执行过程，是临时的，动态产生动态消亡
b.并发性：任何进程都可同其他进程一起并发执行
c.独立性：是系统进行资源分配和调度的一个独立单位
d.结构性：进程由程序、数据、和进程控制块（PCB）三部分组成
9.CPU：计算机的核心，承担了所有的计算任务
10.OS：计算机的管理者，负责任务的调度。资源的分配和管理，统领整个计算机硬件
11.应用程序：具有某种功能的程序，程序是运行与OS之上的
12.每一个处理核心对应一个内核线程（Kernel Thread），KLT是直接由OS内核支持的Thread，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各处理器上，一般一个处理核心对应一个内核线程
13.现在电脑一般采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，因此在OS中看到的CPU数量是实际物理CPU数量的两倍
14.程序一般不会直接去使用内核线程，而是去使用内核线程的的一种高级接口--LWP，即通常意义上的线程（在这里称为用户线程）
15.在任务管理器性能选项卡中，CPU使用记录的监视器个数=逻辑处理核心的个数
16.用户线程与内核线程对应关系有1对1模型，多对1模型，多对多模型
17.当线程的数量小于处理器的数量，线程的并发是真正的并发，不同的线程运行在不同的处理器上，但线程数量大于处理器数量时，不是真正的并发
18.进程生命周期有五种状态：创建，就绪，运行，阻塞，退出

#线程优先级与线程安全
1.线程饿死是说它的优先级较低，在它执行之前总是有比它优先级更高的线程等待执行，因此这个低优先级的线程始终得不到执行
2.频繁等待的线程称之为IO密集型线程(IO Bound Thread)，而把很少等待的线程称之为CPU密集型线程(CPU Bound Thread)。IO密集型线程总是比CPU密集型线程更容易得到优先级的提升
3.为了避免线程饿死，调度系统通常会逐步提升那些等待了很久而得不到执行的线程的优先级。这样，一个线程只要它等待了足够长的时间，其优先级总会被提升到可以让它执行的程度，也就是说这种情况下线程始终会得到执行，只是时间的问题
4.在优先级调度环境下，线程优先级的改变有三种方式： 
a. 用户指定优先级； 
b. 根据进入等待状态的频繁程度提升或降低优先级(由操作系统完成)； 频繁地进入等待状态(进入等待状态会放弃之前仍可占用的时间份额)的线程(如IO线程)，比频繁进行大量计算以至于每次都把所有时间片全部用尽的线程更受操作系统的欢迎。因为频繁进入等待的线程只会占用很少的时间，这样操作系统可以处理更多的任务
c. 长时间得不到执行而被提升优先级。
5.我们要将多个线程对同一数据的访问同步，确保线程安全。同步(synchronization)指同一时刻只能有一个线程访问该数据，当这一线程访问结束时其它线程才能对这它进行访问。
6.同步最常见的方式就是使用锁(Lock)，也称为线程锁。锁是一种非强制机制，每一个线程在访问数据或资源之前，首先试图获取(Acquire)锁，并在访问结束之后释放(Release)锁。在锁被占用时试图获取锁，线程会进入等待状态，直到锁被释放再次变为可用。
7.二元信号量(Binary Semaphore)是一种最简单的锁，它有两种状态：占用和非占用。它适合只能被唯一一个线程独占访问的资源。当二元信号量处于非占用状态时，第一个试图获取该二元信号量锁的线程会获得该锁，并将二元信号量锁置为占用状态，之后其它试图获取该二元信号量的线程会进入等待状态，直到该锁被释放。
8.多元信号量允许多个线程访问同一个资源，多元信号量简称信号量(Semaphore)，对于允许多个线程并发访问的资源，这是一个很好的选择。一个初始值为N的信号量允许N个线程并发访问。线程访问资源时首先获取信号量锁，进行如下操作： 
a. 将信号量的值减1； 
b. 如果信号量的值小于0，则进入等待状态，否则继续执行； 
访问资源结束之后，线程释放信号量锁，进行如下操作： 
a. 将信号量的值加1； 
c. 如果信号量的值小于1(等于0)，唤醒一个等待中的线程；
9.互斥量(Mutex)和二元信号量类似，资源仅允许一个线程访问。与二元信号量不同的是，信号量在整个系统中可以被任意线程获取和释放，同一个信号量可以由一个线程获取而由另一线程释放。而互斥量则要求哪个线程获取了该互斥量锁就由哪个线程释放
10.临界区(Critical Section)是一种比互斥量更加严格的同步手段。互斥量和信号量在系统的任何进程都是可见的，也就是说一个进程创建了一个互斥量或信号量，另一进程试图获取该锁是合法的。而临界区的作用范围仅限于本进程，其它的进程无法获取该锁。除此之处，临界区与互斥量的性质相同
11.读写锁(Read-Write Lock)允许多个线程同时对同一个数据进行读操作，而只允许一个线程进行写操作。对同一个读写锁，有两种获取方式：共享的(Shared)和独占的(Exclusive)。
当锁处于自由状态时，试图以任何一种方式获取锁都能成功，并将锁置为对应的状态；
如果锁处于共享状态，其它线程以共享方式获取该锁，仍然能成功，此时该锁分配给了多个线程。如果其它线程试图如独占的方式获取处于共享状态的锁，它必须等待所有线程释放该锁
处于独占状态的锁阻止任何线程获取该锁，不论它们以何种方式。
12.一个线程饿死是指线程的优先级较低，在它执行之前总是有比它优先级更高的线程等待执行，因此这个低优先级的线程始终得不到执行

JAVA中的多线程：
1.任何程序至少有一个线程，程序从一开始执行就有一个默认的线程，被称为主线程，只有一个线程的程序是单线程程序
2.在程序需要同时执行多个任务时，可以采用多线程
3.Java给多线程编程提供了内置支持，2种创建线程方法：1.通过实现Runnable接口。2.通过继承Thread类
4.Thread是JDK实现的对线程支持的类，Thread类本身实现了Rnunnable接口，因此Runnable是显示创建线程必须实现的接口，Runnable有且只有一个run方法，不管通过哪种方式创建线程，都必须实现run方法
5.复杂的线程模型中，多个线程共享相同的资源或数据时，会出现多个线程争抢一个资源的情况，此时就要考虑线程的同步（Java中对线程方式支持的最常见的方式是添加synchronized同步锁）
